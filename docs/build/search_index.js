var documenterSearchIndex = {"docs":
[{"location":"plot/","page":"Plot","title":"Plot","text":"CurrentModule = ProteinCoLoc","category":"page"},{"location":"plot/#Functions-to-plot-results","page":"Plot","title":"Functions to plot results","text":"","category":"section"},{"location":"plot/","page":"Plot","title":"Plot","text":"Pages = [\"plot.md\"]","category":"page"},{"location":"plot/#Plotting-functions","page":"Plot","title":"Plotting functions","text":"","category":"section"},{"location":"plot/#Plot-correlation-of-each-image-patch","page":"Plot","title":"Plot correlation of each image patch","text":"","category":"section"},{"location":"plot/","page":"Plot","title":"Plot","text":"The plotting method plots the merged MultiChannelimage an displays the computed correlation metric for each image patch. The correlation mechanism are chosen based on the cor_methodargument: ","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":":pearson: Pearson correlation coefficient (PCC)\n:spearman: Spearman's rank correlation coefficient\n:kendall: Kendall rank correlation coefficient","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"If scale_channels is set to true, the pixel intensities are scaled to a range between 0 and 1 using min-max scaling. ","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"(Image: Patched correlation plot)","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"plot(\n    img::MultiChannelImage,\n    num_patches::T,\n    cor_channel::Vector{T} = [2, 3];\n    scale_channels::Bool = true,\n    file::String = \"test.png\";\n    channel_for_plot::Vector{T} = [1, 2, 3],\n    save_to_file::Bool = true,\n    cor_method::Symbol = :pearson\n    ) where {T <: Int}","category":"page"},{"location":"plot/#ProteinCoLoc.plot-Union{Tuple{T}, Tuple{MultiChannelImage, T}, Tuple{MultiChannelImage, T, Vector{T}}} where T<:Int64","page":"Plot","title":"ProteinCoLoc.plot","text":"plot(\nimg::LoadImages.MultiChannelImage,\nnum_patches::T,\ncor_channel::Vector{T} = [2, 3];\nscale_channels::Bool = true,\nfile::String = \"test.png\";\nchannel_for_plot::Vector{T} = [1, 2, 3],\nsave_to_file::Bool = true,\ncor_method::Symbol = :pearson\n) where {T <: Int}\n\nPlot the image with the patches and the correlation of each patch.\n\n# Arguments\n- `img::LoadImages.MultiChannelImage`: The image to plot.\n- `num_patches::Int64`: The number of patches to use.\n- `cor_channel::Vector{Int64}`: The channels to use for the calculation of correlation.\n- `scale_channels::Bool`: Whether to scale the channels intensities to the range [0, 1].\n- `file::String`: The file to save the plot to. Must end with .png or .svg.\n- `channel_for_plot::Vector{Int64}`: The channels to use for plotting. Only 1-3 channels are supported.\n    The first channel is plotted in blue, the second in green and the third in red.\n- `save_to_file::Bool`: Whether to save the plot to the file.\n- `cor_method::Symbol`: The method to use for the calculation of correlation. Default is :pearson. Other options are :spearman and :kendall.\n\n# Example\n```julia\npath = [\"test_images/c1.tif\", \"test_images/c2.tif\", \"test_images/c3.tif\"]\nimg = LoadImages.MultiChannelImage(\"positive_sample\", path, [\"blue\", \"green\", \"red\"])\nmask = LoadImages._calculate_mask(img)\nLoadImages._apply_mask!(img, mask)\ncor_channel = [2, 3]\nscale_channels = true\nnum_patches = 16\n\nplot(img, num_patches, cor_channel, scale_channels, \"test.png\")\n```\n\n\n\n\n\n","category":"method"},{"location":"plot/#Plot-mask","page":"Plot","title":"Plot mask","text":"","category":"section"},{"location":"plot/","page":"Plot","title":"Plot","text":"As explained in our paper, we use Otsu thresholding to compute a mask. This mask can be visualised using the function plot_mask(img::MultiChannelImage, file::String). In these images all masked pixels are depicted black and non-masked pixels that are included in the analysis are white.","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"(Image: Mask plot)","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"plot_mask","category":"page"},{"location":"plot/#ProteinCoLoc.plot_mask","page":"Plot","title":"ProteinCoLoc.plot_mask","text":"plot_mask(img::LoadImages.MultiChannelImage,file::String = \"test.png\")\nPlot the mask of the image with the channels separated by lines.\nSave the plot to the file and also return it.\n\n# Arguments\n- `img::LoadImages.MultiChannelImage`: The image to plot.\n- `file::String`: The file to save the plot to. Must end with .png or .svg.\n\n\n\n\n\n","category":"function"},{"location":"plot/#Plot-local-correlation-plot","page":"Plot","title":"Plot local correlation plot","text":"","category":"section"},{"location":"plot/","page":"Plot","title":"Plot","text":"The local correlation plot allows for the visualisation of local colocalization patterns at a finer spatial scale and enables visualising variations in colocalization intensity within small image patches (ideally between 10 and 100 px). Robust estimates for individual patches are ensured by performing a correlation between intensities only if 15 or more pixels in a patch have intensities above Otsu’s threshold for both channels. If the chosen number of patches is too high, the number of patches is dynamically adjusted until at least 15 pixels in a patch have non-masked intensities. ","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"(Image: Local correlation plot)","category":"page"},{"location":"plot/","page":"Plot","title":"Plot","text":"local_correlation_plot","category":"page"},{"location":"plot/#ProteinCoLoc.local_correlation_plot","page":"Plot","title":"ProteinCoLoc.local_correlation_plot","text":"local_correlation_plot(\nimg::MultiChannelImage,\nnum_patches::Int,\ncor_channel::Vector{Int} = [2, 3];\nchannel_for_plot::Vector{Int} = [1, 2, 3],\nsave::Bool = true,\nfile::String = \"local_correlation.png\",\ncor_method::Symbol = :pearson\n)\n\nThis function generates a local correlation plot for a multi-channel image.\n\nArguments\n\nimg: A MultiChannelImage representing the image.\nnum_patches: An integer representing the number of patches to be analyzed.\ncor_channel: A Vector of two integers representing the channels for which the correlation is to be calculated. Default is [2, 3].\nchannel_for_plot: A Vector of integers representing the channels to be plotted. Default is [1, 2, 3].\nsave: A boolean indicating whether to save the plot to a file. Default is true.\nfile: A string representing the filename for the output file. Default is \"local_correlation.png\".\ncor_method: A Symbol representing the method to be used for the calculation of correlation. Default is :pearson. Other options are :spearman and :kendall.\n\nReturns\n\nfig: A Figure object representing the generated plot.\n\nErrors\n\nThrows a warning if no patches with a successful correlation calculation exist.\nThrows a warning if no local correlation plot could be generated.\n\nNotes\n\nThis function calculates the local correlation for each patch, checks that patches with a successful correlation calculation exist, tries a different patch size if necessary, plots the local correlation, and saves the plot to a file if specified.\n\n\n\n\n\n","category":"function"},{"location":"plot/#Helper-functions","page":"Plot","title":"Helper functions","text":"","category":"section"},{"location":"plot/","page":"Plot","title":"Plot","text":"minmax_norm!(img::Matrix{Float64})","category":"page"},{"location":"plot/#ProteinCoLoc.minmax_norm!-Tuple{Matrix{Float64}}","page":"Plot","title":"ProteinCoLoc.minmax_norm!","text":"minmax_norm!(img::Matrix{Float64})\n\nThis function normalizes a 2D image matrix to the range [0, 1].\n\nArguments\n\nimg: A 2D matrix of Float64 representing the image to be normalized.\n\nReturns\n\nimg: The input image matrix, modified in-place, where each pixel value has been normalized to the range [0, 1].\n\nNotes\n\nThis function normalizes the image by subtracting the minimum pixel value from each pixel, and then dividing each pixel by the range of pixel values (maximum - minimum). The normalization is performed in-place, modifying the input image matrix directly.\n\n\n\n\n\n","category":"method"},{"location":"plot/","page":"Plot","title":"Plot","text":"cm_to_px","category":"page"},{"location":"plot/#ProteinCoLoc.cm_to_px","page":"Plot","title":"ProteinCoLoc.cm_to_px","text":"cm_to_px(cm::Float64, dpi::Int)::Int\n\nThis function converts a measurement from centimeters to pixels, given a specific dots per inch (dpi) value.\n\nArguments\n\ncm: A Float64 representing the measurement in centimeters.\ndpi: An integer representing the dots per inch (dpi) value.\n\nReturns\n\npx: An integer representing the measurement in pixels.\n\nNotes\n\nThis function first converts the measurement from centimeters to inches, then converts the measurement from inches to pixels using the dpi value. The result is rounded to the nearest integer.\n\n\n\n\n\n","category":"function"},{"location":"plot/","page":"Plot","title":"Plot","text":"calculate_font_size","category":"page"},{"location":"plot/#ProteinCoLoc.calculate_font_size","page":"Plot","title":"ProteinCoLoc.calculate_font_size","text":"calculate_font_size(\nresolution::Tuple{Int, Int}, \nscale_factor::Float64\n)\n\nThis function calculates the font size based on the resolution of the plot and a scale factor.\n\nArguments\n\nresolution: A tuple of two integers representing the width and height of the plot in pixels.\nscale_factor: A Float64 representing the scale factor to be applied to the resolution to calculate the font size.\n\nReturns\n\nfont_size: An integer representing the calculated font size.\n\nNotes\n\nThis function calculates the font size by taking the minimum of the width and height of the plot, multiplying it by the scale factor, and rounding the result to the nearest integer.\n\n\n\n\n\n","category":"function"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"CurrentModule = ProteinCoLoc","category":"page"},{"location":"loading_image/#Loading-images","page":"Load Images","title":"Loading images","text":"","category":"section"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"Pages = [\"loading_image.md\"]","category":"page"},{"location":"loading_image/#Data-types-and-Interface","page":"Load Images","title":"Data types and Interface","text":"","category":"section"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"All images need to be represented as the mutable struct MultiChannelImage for further use with ProteinCoLoc.jl. This MultiChannelImage allows storing all pixel itensities, channel names, the image name, path to the individual channel images, the size of the image as well as the Otsu's threshold for each color channel. ","category":"page"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"MultiChannelImage","category":"page"},{"location":"loading_image/#ProteinCoLoc.MultiChannelImage","page":"Load Images","title":"ProteinCoLoc.MultiChannelImage","text":"mutable struct MultiChannelImage{T <: Union{Missing, Float64}, S <: AbstractString, F <: AbstractFloat}\n\nThis mutable struct represents a multi-channel image.\n\nFields\n\ndata::Vector{Matrix{T}}: A Vector of Matrix{T} representing the image data for each channel.\nchannels::Vector{S}: A Vector of strings representing the names of the channels.\nname::S: A string representing the name of the image.\npath::Vector{S}: A Vector of strings representing the paths to the image files for each channel.\npixel_size::Tuple{F, F}: A Tuple of two Float64 representing the width and height of the pixels in micrometers.\notsu_threshold::Vector{F}: A Vector of Float64 representing the Otsu threshold for each channel.\n\nConstructor\n\nThe constructor checks that the lengths of the data, channels, and otsu_threshold vectors match.\n\nNotes\n\nThis struct is used to store and manipulate multi-channel images in the ProteinCoLoc package.\n\n\n\n\n\n","category":"type"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"A MultiChannelImage can be created either manually or by calling the external constructor that loads tiff files into a MultiChannelImage ","category":"page"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"MultiChannelImage(name::S, path::Vector{S}, channels::Vector{S} =[]) where {S <: AbstractString}","category":"page"},{"location":"loading_image/#ProteinCoLoc.MultiChannelImage-Union{Tuple{S}, Tuple{S, Vector{S}}, Tuple{S, Vector{S}, Vector{S}}} where S<:AbstractString","page":"Load Images","title":"ProteinCoLoc.MultiChannelImage","text":"MultiChannelImage(name::S, path::Vector{S}, channels::Vector{S} =[]) where {S <: AbstractString}\n\nThis constructor creates a new MultiChannelImage.\n\nArguments\n\nname: A string representing the name of the image.\npath: A Vector of strings representing the paths to the image files for each channel.\nchannels: A Vector of strings representing the names of the channels. Default is an empty Vector.\n\nReturns\n\nimg: A MultiChannelImage representing the loaded image.\n\nNotes\n\nThis constructor loads the image data from the files at the specified paths, checks if channel names are provided and generates default names if not, calculates the pixel size and Otsu threshold for each channel, and creates a new MultiChannelImage with these values.\n\n\n\n\n\n","category":"method"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"Several instances of type MultiChannelImage can be stored as a MultiChannelImageStack{T <:MultiChannelImage, S <: AbstractString}. For example images taken from the samples of the same biological condition can be grouped in an MultiChannelImageStackfor further downstream analysis. A MultiChannelImageStackcan be generated by using the constructor MultiChannelImageStack(img, name)  ","category":"page"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"MultiChannelImageStack","category":"page"},{"location":"loading_image/#ProteinCoLoc.MultiChannelImageStack","page":"Load Images","title":"ProteinCoLoc.MultiChannelImageStack","text":"mutable struct MultiChannelImageStack{T <: MultiChannelImage, S <: AbstractString}\n\nThis mutable struct represents a stack of multi-channel images.\n\nFields\n\nimg: A Vector of MultiChannelImage representing the images in the stack.\nname: A string representing the name of the image stack.\nnum_images: An Int64 representing the number of images in the stack.\n\nConstructor\n\nThe constructor takes a Vector of MultiChannelImage and a string as arguments, and sets the num_images field to the length of the Vector.\n\nNotes\n\nThis struct is used to store and manipulate stacks of multi-channel images in the ProteinCoLoc package.\n\n\n\n\n\n","category":"type"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"The following methods are defined for an object of type MultiChannelImageStack:","category":"page"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"getindex(stack, i): Method to retrieve the MultiChannelImage at index i of the MultiChannelImageStack stack.\nìterate(stack, state): Method to iterate over the images in the MultiChannelImageStack stack. This method definition allows the use of for-loops etc with MultiChannelImageStacks. ","category":"page"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"Base.getindex(stack::MultiChannelImageStack, i::Int64)\nBase.iterate(stack::MultiChannelImageStack, state)","category":"page"},{"location":"loading_image/#Base.getindex-Tuple{MultiChannelImageStack, Int64}","page":"Load Images","title":"Base.getindex","text":"Base.getindex(stack::MultiChannelImageStack, i::Int64)\n\nFunction to retrieve an image from a MultiChannelImageStack.\n\nArguments\n\nstack: A MultiChannelImageStack from which to retrieve an image.\ni: An Int64 representing the index of the image to retrieve.\n\nReturns\n\nimg: A MultiChannelImage representing the image at index i in the stack.\n\nErrors\n\nThrows a BoundsError if i is greater than the number of images in the stack.\n\nNotes\n\nThis function checks that i is within the bounds of the stack, and returns the image at index i.\n\n\n\n\n\n","category":"method"},{"location":"loading_image/#Base.iterate-Tuple{MultiChannelImageStack, Any}","page":"Load Images","title":"Base.iterate","text":"Base.iterate(stack::MultiChannelImageStack, state=1)\n\nThis function overrides the base iterate function to iterate over the images in a MultiChannelImageStack.\n\nArguments\n\nstack: A MultiChannelImageStack over which to iterate.\nstate: An Int64 representing the current state of the iteration. Default is 1.\n\nReturns\n\nA tuple containing the current image and the next state, or nothing if the end of the stack has been reached.\n\nNotes\n\nThis function checks if the state is greater than the number of images in the stack, and if so, returns nothing. Otherwise, it returns the current image and the next state.\n\n\n\n\n\n","category":"method"},{"location":"loading_image/#Load-tiff-file","page":"Load Images","title":"Load tiff-file","text":"","category":"section"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"Images can be loaded from a file using the function 'load_tiff'. This function converts the RGB image into a greyscale image and returns a Matrix{Float64}","category":"page"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"load_tiff(path::S) where {S<:AbstractString}","category":"page"},{"location":"loading_image/#ProteinCoLoc.load_tiff-Tuple{S} where S<:AbstractString","page":"Load Images","title":"ProteinCoLoc.load_tiff","text":"load_tiff(path::S) where {S<:AbstractString}\n\nThis function loads a TIFF image from a file and converts it to a matrix of Float64 values, where the values represent the intensity in grayscale.\n\nArguments\n\npath: A string representing the path to the TIFF image file.\n\nReturns\n\nimg: A Matrix of Float64 representing the grayscale intensity of the image.\n\nNotes\n\nThis function uses the Images.jl package to load the image, convert it to grayscale, and then convert it to a matrix.\n\n\n\n\n\n","category":"method"},{"location":"loading_image/#Computing-and-applying-image-mask","page":"Load Images","title":"Computing and applying image mask","text":"","category":"section"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"The image mask using Otsu thresholding can be computed and directly applied to an img of type MultiChannelImage using the function apply_mask!(img).","category":"page"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"apply_mask!","category":"page"},{"location":"loading_image/#ProteinCoLoc.apply_mask!","page":"Load Images","title":"ProteinCoLoc.apply_mask!","text":"apply_mask!(img)\n\nThis function calculates a  mask for a MultiChannelImage using Otsu thresholding and directly applies it to the image.\n\n# Arguments\n- `img`: A MultiChannelImage to which to apply the mask.\n\n# Returns\n- `img`: The MultiChannelImage with the mask applied.\n\n\n\n\n\n","category":"function"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"warning: _calculate_mask and _apply_mask! are not part of the public API\nIn addition, two low-level function are available to perform these steps individually. These functions are not part of the public API and might change in the future. ","category":"page"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"_calculate_mask\n_apply_mask!(img, mask)","category":"page"},{"location":"loading_image/#ProteinCoLoc._calculate_mask","page":"Load Images","title":"ProteinCoLoc._calculate_mask","text":"_calculate_mask(img::MultiChannelImage)\n\nThis function calculates a binary mask for each channel of a MultiChannelImage, where pixels with intensity greater than the Otsu threshold are set to 1 and others are set to 0.\n\nArguments\n\nimg: A MultiChannelImage for which to calculate the mask.\n\nReturns\n\nmask: A Vector of Matrix{Bool} representing the binary mask for each channel.\n\nNotes\n\nThis function iterates over the channels of the image, applies the Otsu threshold to the data of each channel, and stores the resulting binary mask.\n\n\n\n\n\n","category":"function"},{"location":"loading_image/#ProteinCoLoc._apply_mask!-Tuple{Any, Any}","page":"Load Images","title":"ProteinCoLoc._apply_mask!","text":"_apply_mask!(img::MultiChannelImage, mask::Vector{Matrix{Bool}})\n\nThis function applies a binary mask to each channel of a MultiChannelImage, where pixels in the mask that are set to 0 are set to 0 in the image.\n\nArguments\n\nimg: A MultiChannelImage to which to apply the mask.\nmask: A Vector of Matrix{Bool} representing the binary mask for each channel.\n\nReturns\n\nimg: The MultiChannelImage with the mask applied.\n\nNotes\n\nThis function iterates over the channels of the image, multiplies the data of each channel by the corresponding mask, and stores the result back in the image.\n\n\n\napply_mask!(img::MultiChannelImage)\n\nThis function calculates a binary mask for a MultiChannelImage and applies it to the image.\n\nArguments\n\nimg: A MultiChannelImage to which to apply the mask.\n\nReturns\n\nimg: The MultiChannelImage with the mask applied.\n\nNotes\n\nThis function calls the _calculate_mask function to calculate the mask, and then calls the _apply_mask! function to apply the mask to the image.\n\n\n\n\n\n","category":"method"},{"location":"loading_image/#Generation-of-control-images","page":"Load Images","title":"Generation of control images","text":"","category":"section"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"ProteinCoLocs provides two different ways to generate artificial control images. As discussed in our paper, the use of randomly shuffled or block shuffled image are not ideal as these may lead to unreliable results. Therefore, we strongly recommend the use of dedicated control images (e.g. control staining without primary antibodies) that have been taken with the same settings.","category":"page"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"The first image randomly shuffles all pixels of each color channel. ","category":"page"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"shuffle_pixels","category":"page"},{"location":"loading_image/#ProteinCoLoc.shuffle_pixels","page":"Load Images","title":"ProteinCoLoc.shuffle_pixels","text":"shuffle_pixels(img::MultiChannelImage)\n\nThis function shuffles the pixel values in each channel of a MultiChannelImage.\n\nArguments\n\nimg: A MultiChannelImage whose pixel values are to be shuffled.\n\nReturns\n\nimg: The MultiChannelImage with shuffled pixel values.\n\nNotes\n\nThis function iterates over the channels of the image, shuffles the pixel values in each channel using the shuffle! function from the Julia standard library, and stores the result back in the image.\n\n\n\n\n\n","category":"function"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"The second method shuffles blocks of pixels in each channel of a MultiChannelImage. The block shuffling should retain the autocorrelation between neighboring pixels.","category":"page"},{"location":"loading_image/","page":"Load Images","title":"Load Images","text":"shuffle_blocks","category":"page"},{"location":"loading_image/#ProteinCoLoc.shuffle_blocks","page":"Load Images","title":"ProteinCoLoc.shuffle_blocks","text":"shuffle_blocks(img::MultiChannelImage, block_size::Int64)\n\nThis function shuffles the blocks of pixel values in each channel of a MultiChannelImage.\n\nArguments\n\nimg: A MultiChannelImage whose pixel blocks are to be shuffled.\nblock_size: An Int64 representing the size of the blocks to be shuffled.\n\nReturns\n\nimg: The MultiChannelImage with shuffled pixel blocks.\n\nNotes\n\nThis function calculates the number of blocks in each channel, retrieves the pixel values, shuffles the blocks, and stores the result back in the image. The shuffling is done by creating a new array with the first two dimensions shuffled. The blocks are then unpatched and the image data is updated.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ProteinCoLoc","category":"page"},{"location":"#ProteinCoLoc","page":"Home","title":"ProteinCoLoc","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ProteinCoLoc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
