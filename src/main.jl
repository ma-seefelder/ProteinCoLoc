#=
ProteinCoLoc: A Julia package for the analysis of protein co-localization in microscopy images
Copyright (C) 2023  Dr. rer. nat. Manuel Seefelder
E-Mail: manuel.seefelder@uni-ulm.de
Postal address: Department of Gene Therapy, University of Ulm, Helmholzstr. 8/1, 89081 Ulm, Germany

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
 any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
=#

# This file contains the main API functions for the ProteinCoLoc.jl package.
# The functions are exported and can be used by the user.
# Additionally, the function is called by the GUI to perform the analysis.


function _main_checks(;number_channels, number_patches, image_path, output_folder_path, channel_selection_two, ρ_range)
    number_channels < 2 && @error "The number of channels must be >= 2."
    number_patches < 1 && error("The number of patches must be >= 1.")
    length(channel_selection_two) != 2 && @error("The number of selected channels must be 2.")

    !isdir(image_path) && @error "The image path $image_path does not exist."
    !isdir(output_folder_path) && @error "The output folder path  $output_folder_path does not exist."
    
    log_path = joinpath(output_folder_path, "log.txt")
    isfile(log_path) && @error "The output folder $output_folder_path contains a log file. Please choose another output folder or delete the log file and results from a previous analysis."
    
    results_path = joinpath(output_folder_path, "result.txt")
    isfile(results_path) && @error "The output folder $output_folder_path contains a results file. Please choose another output folder or delete the results file and results from a previous analysis."
    
    ρ_range[1] >= ρ_range[2] && error("ρ_range[1] must be smaller than ρ_range[2]: $(ρ_range[1]) >= $(ρ_range[2]).")
    
    return false
end

function _main_load_control(
    shuffle::Bool, path::S, number_channels::I, path_sample::S ="", 
    shuffle_method::Symbol = :block
    ) where {S<:AbstractString, I<:Integer}

    if !shuffle 
        isdir(path) || @error "The control image path is not valid."  
        return get_images(path, number_channels, "control images")
    end

    shuffle_method ∈ [:pixel, :block] || error("The shuffling method is not supported. Please choose either :pixel or :block.")


    unshuffled = get_images(path_sample, number_channels, "shuffled_control", mask = false)
    control = Vector{MultiChannelImage}(undef, unshuffled.num_images)
    
    for (idx, img) in enumerate(unshuffled)
        img.name = "shuffled_control_" * img.:name
        shuffle_method == :pixel ? control[idx] = shuffle_pixels(img) : control[idx] = shuffle_blocks(img, 9)
    end
    println("Control images have been generated by $shuffle_method.")
    return MultiChannelImageStack(control, "shuffled_control")
end


const options_plots_default = Dict(
    "patched_correlation_plt" => true,
    "local_correlation_plt" => true, "bayes_factor_plt" => true,
    "bayes_range_plt" => true, "posterior_plt" => true, "mask_plt" => true
)

"""
    start_analysis(
    image_path::S,
    control_image_path::S,
    output_folder_path::S,
    number_patches::I,
    number_patches_loc::I,
    number_channels::I;
    channel_selection::Bool = false,
    channel_selection_two::Vector{I} = [1,2],
    plot_options::Dict{S, Bool} = options_plots_default,
    number_iterations::I = 1000,
    number_posterior_samples::I = 100_000,
    ρ_threshold::Float64 = 0.1,
    ρ_range::Vector{Float64} = [-0.8, 0.8],
    ρ_range_step::Float64 = 0.01,
    shuffle::Bool = false,
    shuffle_method::Symbol = :block,
    cor_method::Symbol = :pearson
    ) where {S<:AbstractString, I<:Integer}

This function starts the analysis of multi-channel images.

# Arguments

## Required arguments
- `image_path`: A string representing the path to the images.
- `control_image_path`: A string representing the path to the control images.
- `output_folder_path`: A string representing the path to the output folder.
- `number_patches`: An integer representing the number of patches.
- `number_patches_loc`: An integer representing the number of patches for local correlation.
- `number_channels`: An integer representing the number of channels.

## Optional arguments
- `channel_selection`: A boolean indicating whether to select channels. If false, all possible combinations of channels are analyzed. 
- `channel_selection_two`: A Vector of integers representing the two selected channels.
- `patched_correlation_plt`: A boolean indicating whether to plot the patched correlation.
- `plot_options`: A Dict of booleans representing the plot options with the following keys: "patched_correlation_plt", "local_correlation_plt", "bayes_factor_plt", "bayes_range_plt", "posterior_plt", "mask_plt".
- `number_iterations`: An integer representing the number of iterations. Default is 1000.
- `number_posterior_samples`: An integer representing the number of posterior samples. Default is 100_000.
- `ρ_threshold`: A Float64 representing the threshold for the Bayes factor. Default is 0.1.
- `ρ_range`: A Vector of Float64 representing the range for the Bayes factor range plot. Default is [-0.8, 0.8].
- `ρ_range_step`: A Float64 representing the step size for the Bayes factor range plot. Default is 0.01.
- `shuffle`: A boolean indicating whether to shuffle patches. Default is false.
- `shuffle_method`: A Symbol representing the shuffle method. Default is :block.
- `cor_method`: A Symbol representing the correlation method. Default is :pearson. Can be :pearson, :spearman, or :kendall.

"""
function start_analysis(
    image_path::S,
    control_image_path::S,
    output_folder_path::S,
    number_patches::I,
    number_patches_loc::I,
    number_channels::I;
    channel_selection::Bool = false,
    channel_selection_two::Vector{I} = [1,2],
    plot_options::Dict{S, Bool} = options_plots_default,
    number_iterations::I = 1000,
    number_posterior_samples::I = 100_000,
    ρ_threshold::Float64 = 0.1,
    ρ_range::Vector{Float64} = [-0.8, 0.8],
    ρ_range_step::Float64 = 0.01,
    shuffle::Bool = false,
    shuffle_method::Symbol = :block,
    cor_method::Symbol = :pearson
    ) where {S<:AbstractString, I<:Integer}

    if _main_checks(
        number_channels = number_channels, 
        number_patches = number_patches, 
        image_path = image_path, 
        output_folder_path = output_folder_path, 
        channel_selection_two = channel_selection_two, 
        ρ_range = ρ_range
        ) == false
        @info "Analysis and plotting aborted"
        return nothing
    end

    @info "Starting analysis..."
    ###########################################################################
    # load and preprocess images
    ###########################################################################
    # load images
    images = get_images(image_path, number_channels, "images")
    control_images = _main_load_control(shuffle, control_image_path, number_channels, image_path, shuffle_method)

    @info "Images loaded successfully"
    ###########################################################################
    # perform analysis and plotting
    ###########################################################################
    # unpack plot options
    local_correlation_plt = plot_options["local_correlation_plt"]
    patched_correlation_plt = plot_options["patched_correlation_plt"]
    bayes_factor_plt = plot_options["bayes_factor_plt"]
    bayes_range_plt = plot_options["bayes_range_plt"]
    posterior_plt = plot_options["posterior_plt"]
    mask_plt = plot_options["mask_plt"]

    @info "Starting Bayesian inference and plotting..."
    if channel_selection
        prior, posterior, bf = generate_plots(
            images, control_images, channel_selection_two, number_patches, number_patches_loc, 
            number_iterations, number_posterior_samples, ρ_threshold, 
            ρ_range, ρ_range_step, output_folder_path, patched_correlation_plt, local_correlation_plt, 
            bayes_factor_plt, bayes_range_plt, posterior_plt, cor_method
            )

        if !ismissing(prior)
            generate_txt(prior, posterior, bf, channel_selection_two, ρ_threshold, file = joinpath(output_folder_path, "result.txt"))
            # write the DataFrames prior_samples and posterior_samples to csv
            CSV.write(
                joinpath(output_folder_path,"prior_samples_channel$(string(channel_selection_two[1]))_$(channel_selection_two[2]).csv"),
                get_samples(prior)
                )

            CSV.write(
                joinpath(output_folder_path,"posterior_samples_channel$(string(channel_selection_two[1]))_$(channel_selection_two[2]).csv"),
                get_samples(posterior)
                )
        end
    else
        # extract all possible combinations of channels 
        channel_combinations = combinations2(number_channels)
        # iterate over all channel combinations
        for channels ∈ channel_combinations
            prior, posterior, bf = generate_plots(
                images, control_images, channels, number_patches, number_patches_loc, 
                number_iterations, number_posterior_samples, ρ_threshold, 
                ρ_range, ρ_range_step, output_folder_path, patched_correlation_plt, local_correlation_plt, 
                bayes_factor_plt, bayes_range_plt, posterior_plt, cor_method)

            if !ismissing(prior)
                generate_txt(prior, posterior, bf, channels, ρ_threshold, file = joinpath(output_folder_path, "result.txt"))
                # write the DataFrames prior_samples and posterior_samples to csv
                CSV.write(
                    joinpath(output_folder_path,"prior_samples_channel$(string(channels[1]))_$(channels[2]).csv"),
                    get_samples(prior)
                )

                CSV.write(
                    joinpath(output_folder_path,"posterior_samples_channel$(string(channels[1]))_$(channels[2]).csv"),
                    get_samples(posterior)
                )
            end
        end
    end

    # mask plot
    if mask_plt
        [plot_mask(img, joinpath(output_folder_path, "mask$(img.name).png")) for img ∈ images]
        [plot_mask(img, joinpath(output_folder_path, "mask_control_$(img.name).png")) for img ∈ control_images]
    end

    @info "Analysis and plotting finished successfully"
end