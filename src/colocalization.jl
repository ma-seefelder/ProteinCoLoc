## colocalization.jl
# This file is part of ProteinCoLoc.jl, licensed under the MIT License (MIT).
# See LICENSE.md in the project root for license information.
# Author: Manuel Seefelder

#module Colocalization
include("LoadImages.jl")
import .LoadImages
using Turing

path = ["test_images/c1.tif", "test_images/c2.tif", "test_images/c3.tif"]
img = LoadImages.MultiChannelImage("positive_sample", path, ["blue", "green", "red"])

function patch(img::Array{Float64, 2}, num_patches::Int64)
    @warn "This function is generated by github copilot and is not tested." 
    # calculate the size of the patches
    patch_size = Int64(floor(size(img, 1) / num_patches))
    # calculate the number of patches
    num_patches = Int64(floor(size(img, 1) / patch_size))
    # initialize the patches
    patches = zeros(num_patches, num_patches, patch_size, patch_size)
    # loop over the patches
    for i in 1:num_patches
        for j in 1:num_patches
            patches[i, j, :, :] = img[(i-1)*patch_size+1:i*patch_size, (j-1)*patch_size+1:j*patch_size]
        end
    end
    return patches
end


function colocalization_Model(
    img::LoadImages.MultiChannelImage, 
    control::LoadImages.MultiChannelImage, 
    channels::Vector{Int64},
    num_patches::Int64 = 1
    )
    # calculate colocalization
    x = img.data[channels[1]]
    y = img.data[channels[2]]
    x_control = control.data[channels[1]]
    y_control = control.data[channels[2]]

    # assert that the images are the same size
    @assert size(x) == size(y) == size(x_control) == size(y_control) "Images are not the same size"

    # patch the image
    x, y, x_control, y_control = patch.([x, y, x_control, y_control], num_patches)

    # calculate the correlation for each patch
    @error "not implemented"
    #TODO: not implemented

    # Fisher's z-transformation of the correlation coefficients
    ρ_sample = atanh.(ρ_sample)
    ρ_control = atanh.(ρ_control)

    ###############################
    # Turing model
    ###############################

    @model function model_singular_image(x = ρ_control, y = ρ_sample)
        # get the number of patches
        num_patches = size(x, 1)

        # hyperpriors
        μ_control ~ Normal(0, 1)
        σ_control ~ InverseGamma(2, 3)
        ν_control ~ Gamma(2, 0.1)

        μ_sample ~ Normal(0, 1)
        σ_sample ~ InverseGamma(2, 3)
        ν_sample ~ Gamma(2, 0.1)

        # priors
        # get prior for each patch
        μ_control_patch ~ filldist(Normal(μ_control, σ_control), num_patches)
        σ_control_patch ~ filldist(InverseGamma(σ_control, 3), num_patches)
        ν_control_patch ~ filldist(InverseGamma(ν_control, 0.1), num_patches)

        μ_sample_patch ~ filldist(Normal(μ_sample, σ_sample), num_patches)
        σ_sample_patch ~ filldist(InverseGamma(σ_sample, 3), num_patches)
        ν_sample_patch ~ filldist(InverseGamma(ν_sample, 0.1), num_patches)

        # likelihood for correlation
        for p ∈ 1:size(x, 1) # iterate over patches
            [x[p], y[p]] ~ MvTDist(ν_sample_patch[p], μ_sample_patch[p], σ_sample_patch[p])
            [x_control[p], y_control[p]] ~ MvTDist(ν_control_patch[p], μ_control_patch[p], σ_control_patch[p])
        end  
               
    end

end


function colocalization(img::LoadImages.MultiChannelImage, channels::Vector{Int64})
    mask = LoadImages._calculate_mask(img)
    LoadImages._apply_mask!(img, mask)

    # calculate colocalization
    channel_1 = img.data[channels[1]]
    channel_2 = img.data[channels[2]]

    # calculate colocalization



    return img
end